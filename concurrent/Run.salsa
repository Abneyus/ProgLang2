module concurrent;

import java.io.*;
import java.util.*;

behavior Run {
  void act(String[] args)
  {
    ArrayList actors = new ArrayList();
    int actorCount = 0;

    try
    {
      FileReader fb = new FileReader("config.tsv");
      BufferedReader in = new BufferedReader(fb);

      String temp = temp = in.readLine();
      while(temp != null)
      {
        String[] bits = temp.split("\t");

        if(actors.size() == 0)
        {
          actors.add(new Dude(Integer.parseInt(bits[0]),
                    bits[1],
                    Integer.parseInt(bits[2]),
                    Integer.parseInt(bits[3]),
                    Integer.parseInt(bits[4]),
                    null,
                    null));
          // Edge case where there is only one actor.
          actors.get(0) <- setLeft(actors.get(0));
          actors.get(0) <- setRight(actors.get(0));
          actorCount+=1;
        }
        else
        {
          actors.add(new Dude(Integer.parseInt(bits[0]),
                    bits[1],
                    Integer.parseInt(bits[2]),
                    Integer.parseInt(bits[3]),
                    Integer.parseInt(bits[4]),
                    (Dude) actors.get(actorCount-1),
                    (Dude) actors.get(0)));
          actorCount+=1;
          actors.get(actorCount-2) <- setRight(actors.get(actorCount-1));
        }

        temp = in.readLine();
      }

      in.close();
      fb.close();
    }
    catch (IOException ioe)
    {
      standardOutput<-println("[error] Can't open the config.tsv file for reading.");
      System.exit(1);
    }

    actors.get(0) <- setLeft(actors.get(actorCount-1));

    // Finished creating ring

    for(int a = 0; a < actors.size(); a++)
    {
      actors.get(a) <- campaign();
    }


    /* ***
    this is a bunch of stuff that probably won't compile. I'm not sure
    how you use return values in salsa, so I gave up for now.

    the logic for the algorithm is probably mostly correct here.

    elect() doesn't exist yet, but would probably be what you were
    going for with campaign()
    passTime also doesn't exist yet, but it'd be a Dude function that
    passes the time around the circle and records the number of revolts.
    *** */

    // int regimes=0, time =0, timeSinceLastElection, revolted=0, leaderID=-1;
    // boolean electionTime=true;
    //
    // leaderID=elect(actors.get(0));
    // actors.get(leaderID).setPastLeader(true);
    //
    // while(regimes<actors.size())
    // {
    //   if(electionTime)
    //   {
    //     //campaign and elect, no time passage
    //     leaderID=elect(actors.get(leaderID));
    //     actors.get(leaderID).setPastLeader(true);
    //     revolted=0;
    //     timeSinceLastElection=0;
    //     regimes++;
    //     electionTime=false;
    //     standardOutput<-println("ID="+leaderID+" became leader at t="+time);
    //
    //     for(int a=0; a<actors.size(); a++)
    //     {
    //       actors.get(a).setRevolted(false);
    //     }
    //   }
    //   else
    //   {
    //     revolted+=actors.get(leaderID).passTime(timeSinceLastElection);
    //     time+=actors.size();
    //     timeSinceLastElection+=actors.size();
    //
    //     if(revolted>actors.size()/2)
    //     {
    //       electionTime=true;
    //       standardOutput<-println("ID="+leaderID+" was deposed at t="+time);
    //     }
    //   }
    // }
    // standardOutput<-println("End of simulation");


  }




}
